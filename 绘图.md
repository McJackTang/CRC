# fig1
- bvp rr 曲线+归一化相对相位曲线+同步度曲线
```python
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from scipy.signal import hilbert, find_peaks
from scipy.signal import  welch, butter, filtfilt
from math import gcd
import math
def simplify_ratio(n, m):
    g = gcd(n, m)
    return (n // g, m // g)  # 返回化简后的(n, m)   
def adjust_phase_to_0_mpi(phi_rr):
    return np.unwrap(phi_rr)  # 使用 np.unwrap() 函数来处理相位跳变问题
def get_hr(y, fs=60, min=30, max=180):
    #fs: 采样频率
    p, q = welch(y, fs, nfft=int(1e6/fs), nperseg=np.min((len(y)-1, 512)))
    return p[(p>min/60)&(p<max/60)][np.argmax(q[(p>min/60)&(p<max/60)])]*60 
from scipy.fft import fft, fftfreq
def calculate_dynamic_n_m_v2(hr_segment, rr_segment, fs=60):
    """
    动态计算 n:m：
      1) 用 get_hr 估计心率 HR_bpm（30–180 bpm）
      2) 用 get_hr 估计呼吸率 VR_bpm（6–60 bpm）
      3) ratio = HR_bpm/VR_bpm，向最近整数取整为 n，m=1
    
    Arguments:
      hr_segment -- 一段心电或脉搏信号（numpy 数组）
      rr_segment -- 一段呼吸或体积信号（numpy 数组）
      fs         -- 采样率 (Hz)
    返回:
      (n, m)     -- 近似的整数比
    """
    # 1) 心率：30–180 bpm
    HR_bpm = get_hr(hr_segment, fs, min=30, max=180)
    # 2) 呼吸率：6–60  bpm
    VR_bpm = get_hr(rr_segment, fs, min=6,  max=30)
    
    # 3) 比值四舍五入
    ratio = HR_bpm / VR_bpm
    n = int(np.round(ratio))
    m = 1
    
    return ratio
def calculate_gamma(sync,ratio_0):
    # Initialize n_m_sync_dict as an empty dictionary
    n_m_sync_dict = {}
    
    n=ratio_0
    #m=1时
    mm=1
    for nn in range((n-1),(n+1)+1):
        if nn <= 1:
            continue #跳过nn=1的情况
        phi_rr_mod=np.mod(sync,2*np.pi*mm)/(2*np.pi)
        window_psi=(2*np.pi/mm) *(np.mod((phi_rr_mod * nn), mm))
        
        cos_sum = (np.sum((np.cos(window_psi)))) / len(window_psi)
        sin_sum = (np.sum((np.sin(window_psi)))) / len(window_psi)
    # 计算同步度
        gamma = cos_sum**2 + sin_sum**2
        n_m_sync_dict[(nn, mm)] = gamma 
    
    #mm=2
    mm=2
    for nn in range((n-1)*2+1,(n+1)*2):
        phi_rr_mod=np.mod(sync,2*np.pi*mm)/(2*np.pi)
        window_psi=(2*np.pi/mm) *(np.mod((phi_rr_mod * nn), mm))
        
        cos_sum = (np.sum((np.cos(window_psi)))) / len(window_psi)
        sin_sum = (np.sum((np.sin(window_psi)))) / len(window_psi)
    # 计算同步度
        gamma = cos_sum**2 + sin_sum**2
        n_m_sync_dict[(nn, mm)] = gamma 
    
    #mm=3
    mm=3
    for nn in range((n-1)*3+1,(n+1)*3):
        phi_rr_mod=np.mod(sync,2*np.pi*mm)/(2*np.pi)
        window_psi=(2*np.pi/mm) *(np.mod((phi_rr_mod * nn), mm))
        
        cos_sum = (np.sum((np.cos(window_psi)))) / len(window_psi)
        sin_sum = (np.sum((np.sin(window_psi)))) / len(window_psi)
    # 计算同步度
        gamma = cos_sum**2 + sin_sum**2
        n_m_sync_dict[(nn, mm)] = gamma 
    
    max_key, max_gamma = max(n_m_sync_dict.items(), key=lambda item: item[1])
    
    
    return max_key, max_gamma
def calculate_dynamic_n_m(hr_segment, rr_segment):
    """根据峰值检测动态调整 n:m"""
    # 获取 hr_segment 和 rr_segment 中的峰值
    hr_peaks, _ = find_peaks(hr_segment, width=10)
    rr_peaks, _ = find_peaks(rr_segment, height=0.5)

    n = len(hr_peaks)  
    m = len(rr_peaks)  

    return round(n/m)
def bandpass_filter(data, lowcut=0.5, highcut=3, fs=30, order=3):
    """Apply a bandpass filter to the data."""
    
    if fs is None or fs <= 0:
        return np.zeros_like(data)
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return filtfilt(b, a, data)
def synchrogram_1(hr_signal, rr_signal, title=""):
    
    hr_min, hr_max = hr_signal.min(), hr_signal.max()
    rr_min, rr_max = rr_signal.min(), rr_signal.max()

    hr_norm = 2*(hr_signal - hr_min) / (hr_max - hr_min)-1
    rr_norm = 2*(rr_signal - rr_min) / (rr_max - rr_min)-1
    # 计算较慢信号（rr_signal）的相位，使用Hilbert变换
    phi_rr = np.angle(hilbert(rr_norm))
    phi_rr = adjust_phase_to_0_mpi(phi_rr)  # 调整相位到 [0, 2πm] 范围
    phi_rr_1 = np.mod(phi_rr, 2 * np.pi )  # 将相位限制在 [0, 2π] 范围内
    phi_rr_2 = np.mod(phi_rr, 4 * np.pi)  # 将相位限制在 [0, 4π] 范围内
    phi_rr_3 = np.mod(phi_rr, 6 * np.pi )  # 将相位限制在 [0, 6π] 范围内
    # 找到较快信号（hr_signal）的峰值位置
    peaks, _ = find_peaks(hr_norm,width=8)  # 找到 hr_signal 的峰值位置
    print(len(peaks))
    #peaks_rr = find_peaks(rr_norm)[0]  # 找到 rr_signal 的峰值位置

    # 在峰值位置提取 rr_signal 的相位
    sync= phi_rr[peaks]  # 提取 rr_signal 的相位
    sync_1 = phi_rr_1[peaks]
    sync_2 = phi_rr_2[peaks]  # 提取 rr_signal 的相位
    sync_3 = phi_rr_3[peaks]  # 提取 rr_signal 的相位
    
    window_size = 600
    ratio_data = []  # 用来保存 (峰值位置, (n, m))
    for i in range(0,len(peaks)): #计算每个峰值位置的 初步猜测的 n:m 比例
        p=peaks[i]
        start = max(0, p - window_size)
        end = min(len(hr_signal), p + window_size)
        hr_seg_local = hr_signal[start:end]
        rr_seg_local = rr_signal[start:end]
        local_n= calculate_dynamic_n_m(hr_seg_local, rr_seg_local)
        ratio_data.append((i, local_n ))
    print(ratio_data)
    gamma_all = []
    max_n_m=[]
    
    N=50
    
    for k in range(N//2,len(peaks)-N//2):
        # 取滑动窗口内的相对相位
        start = int( k - N//2+1)
        end = int(k + N//2+1)
        window_sync = sync[start:end]
        ratio_cur=ratio_data[k][1]
        n_m,gamma_cur=calculate_gamma(window_sync,ratio_cur)
        gamma_all.append(gamma_cur)
        max_n_m.append(n_m)
        
    
    print(f"len(psi_plus):{len(sync)}")
    max_n_m = [simplify_ratio(n, m) for n, m in max_n_m]
    # === 计算同步指标 ===
    
    fs = 60  # 实际采样率
    
    peaks_trimmed = peaks[N//2:len(peaks)-N//2]  # gamma_all 对应的峰值位置
    fs = 60  # 采样率为60Hz
    time = np.arange(len(hr_norm)) / fs 
    # 绘制结果
    fig, axes = plt.subplots(3, 1, figsize=(8, 9))  
    min_val = min(gamma_all)
    max_val = max(gamma_all)
    # 将 peaks 转成以秒为单位
    time_peaks = peaks / fs
    # 绘制同步图
    axes[0].plot(time,hr_norm, 'r', label='bvp_signal')
    axes[0].plot(time,rr_norm, 'b', label='rr_signal')
    axes[0].set_title(f" Signal BVP and RR") 
    axes[0].legend()
    axes[1].plot(time_peaks, sync_1/(2*np.pi), "o",markersize=5)
    axes[1].set_title(r'$\mathrm{\psi}_1(t_k)$', fontsize=13)
    axes[1].set_xlabel("Time(s)")
    axes[1].set_ylabel("Respiratory Cycles")

    # 绘制同步度变化图
    time_peaks_trimmed = time_peaks[N // 2 : len(peaks) - N // 2]
    scaled_gamma_all = [val * 100 for val in gamma_all]

    scaled_min_val = min_val * 100
    scaled_max_val = max_val * 100
    start_tick = math.floor(scaled_min_val * 10) / 10
    end_tick   = math.ceil(scaled_max_val * 10) / 10

    #axes[2].set_ylim([start_tick, end_tick])
    #axes[2].set_yticks(np.arange(start_tick, end_tick + 0.001, 10))  # 设置刻度间隔，比如每 10
    axes[2].set_xlim([time_peaks[0], time_peaks[-1]])
    # 3) 使用 scaled_gamma_all 绘图
    axes[2].plot(time_peaks_trimmed, scaled_gamma_all, '-')

    axes[2].set_title("Synchronization Degree over Time")
    axes[2].set_xlabel("Time (s)")
    axes[2].set_ylabel("Synchronization Degree (%)")  # 或其它更合适的标签
    
    plt.tight_layout()
    plt.show()

hr_pattern = r"060201_v01_hr_0.npy"
rr_pattern = r"060201_v01_rr_0.npy"
bvp_signal= np.load(hr_pattern)
rr_signal = np.load(rr_pattern)
bvp_signal = bandpass_filter(bvp_signal, lowcut=0.5, highcut=3, fs=60, order=3)
rr_signal = bandpass_filter(rr_signal, lowcut=0.1, highcut=0.5, fs=60, order=3)
synchrogram_1(bvp_signal, rr_signal)
   

```
# fig2
- **箱型图**
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kruskal, wilcoxon
import numpy as np  
MRA_DEC=np.load(r"MRA_DEC_T=0.4.npy")
SAP_ACC=np.load(r"SAP_ACC_T=0.4.npy")
MRA_ACC=np.load(r"MRA_ACC_T=0.4.npy")
SAP_DEC=np.load(r"SAP_DEC_T=0.4.npy")
rest1=np.concatenate([MRA_DEC[0],MRA_DEC[2]])
recovery1=np.concatenate([MRA_DEC[1],MRA_DEC[3]])
rest2=np.concatenate([SAP_DEC[0],SAP_DEC[2]])
recovery2=np.concatenate([SAP_DEC[1],SAP_DEC[3]])               
rest3=np.concatenate([MRA_ACC[0],MRA_ACC[2]])
recovery3=np.concatenate([MRA_ACC[1],MRA_ACC[3]])
rest4=np.concatenate([SAP_ACC[0],SAP_ACC[2]])
recovery4=np.concatenate([SAP_ACC[1],SAP_ACC[3]])
state1,p1=wilcoxon(rest1,recovery1)
state2,p2=wilcoxon(rest2,recovery2)
state3,p3=wilcoxon(rest3,recovery3)
state4,p4=wilcoxon(rest4,recovery4)
print(f"MRA_DEC p-value: {p1:.6f}")
print(f"SAP_DEC p-value: {p2:.6f}")
print(f"MRA_ACC p-value: {p3:.6f}")
print(f"SAP_ACC p-value: {p4:.6f}")


import numpy as np  
from scipy.stats import kruskal, wilcoxon

min_gamma = np.load("min_gamma.npy")
max_gamma = np.load("max_gamma.npy")
num_sync = np.load("num_sync.npy")
rest1 = np.concatenate([num_sync[0], num_sync[2]])
recovery1 = np.concatenate([num_sync[1], num_sync[3]])
rest2 = np.concatenate([min_gamma[0], min_gamma[2]])
recovery2 = np.concatenate([min_gamma[1], min_gamma[3]])
rest3 = np.concatenate([max_gamma[0], max_gamma[2]])
recovery3 = np.concatenate([max_gamma[1], max_gamma[3]])
#print("Rest:",rest1, rest2, rest3)
#print("Recovery:",recovery1, recovery2, recovery3)
# 进行 Wilcoxon 配对检验
stat1, p_val1 = wilcoxon(rest1, recovery1, alternative='two-sided')
stat2, p_val2 = wilcoxon(rest2, recovery2, alternative='two-sided')
stat3, p_val3 = wilcoxon(rest3, recovery3, alternative='two-sided')
print(f"num_sync: statistic={stat1:.3f}, p-value={p_val1:.5f}")
print(f"min_gamma: statistic={stat2:.3f}, p-value={p_val2:.5f}")
print(f"max_gamma: statistic={stat3:.3f}, p-value={p_val3:.5f}")
avg_ratio=np.load("avg_ratio.npy", allow_pickle=True)
rest = np.concatenate([avg_ratio[0], avg_ratio[2]])
recovery = np.concatenate([avg_ratio[1], avg_ratio[3]])
state, p = wilcoxon(rest, recovery, alternative='two-sided')
print(f'Rest vs Recovery 频率比 p-value: {p:.4f}')

# p 值转星号
def p_to_asterisks(p):
    if p < 0.001:
        return '***'
    elif p < 0.01:
        return '**'
    elif p < 0.05:
        return '*'
    else:
        return 'ns'

# 合并状态 1 和 3, 2 和 4
def merge_states(data):
    return [np.concatenate([data[0], data[2]]),
            np.concatenate([data[1], data[3]])]

# 加载数据
min_gamma = merge_states(np.load("min_gamma.npy"))
max_gamma = merge_states(np.load("max_gamma.npy"))
num_sync  = merge_states(np.load("num_sync.npy"))
avg_ratio = merge_states(np.load("avg_ratio.npy"))

MRA_DEC = merge_states(np.load("MRA_DEC_T=0.4.npy"))
SAP_DEC = merge_states(np.load("SAP_DEC_T=0.4.npy"))
MRA_ACC = merge_states(np.load("MRA_ACC_T=0.4.npy"))
SAP_ACC = merge_states(np.load("SAP_ACC_T=0.4.npy"))

# 数据和 p 值
metrics_upper = {
    "Min": min_gamma,
    "Max": max_gamma,
    "NumSync": num_sync,
    "FreqRatio": avg_ratio
}
p_values_upper = {
    "Min": 0.00039,
    "Max": 0.02958,
    "NumSync": 0.00195,
    "FreqRatio": 0.048441
}
metrics_lower = {
    "MRA_DEC": MRA_DEC,
    "SAP_DEC": SAP_DEC,
    "MRA_ACC": MRA_ACC,
    "SAP_ACC": SAP_ACC
}
p_values_lower = {
    'MRA_DEC':  0.000004,
    'SAP_DEC': 0.000210,
    'MRA_ACC': 0.000048,
    'SAP_ACC':  0.000322
}

# 创建 2 行 4 列子图
fig, axes = plt.subplots(2, 4, figsize=(20, 8))

# 第一行：Min, Max, NumSync
for i, (name, data) in enumerate(metrics_upper.items()):
    ax = axes[0, i]
    ax.boxplot(data, labels=['State (1&3)', 'State (2&4)'])
    ax.set_title(name)
    ax.set_ylabel('Value')
    ax.grid(True)
    
    y_max = max(np.max(data[0]), np.max(data[1]))
    y_min = min(np.min(data[0]), np.min(data[1]))
    height = y_max + 0.05 * (y_max - y_min)
    ax.plot([1, 2], [height, height], color='black')
    ax.text(1.5, height + 0.01 * (y_max - y_min),
            f"{p_to_asterisks(p_values_upper[name])} (p = {p_values_upper[name]:.4f})",
            ha='center', va='bottom', fontsize=10)


#axes[0, 3].axis('off')

for i, (name, data) in enumerate(metrics_lower.items()):
    ax = axes[1, i]
    ax.boxplot(data, labels=['State (1&3)', 'State (2&4)'])
    ax.set_title(name)
    ax.set_ylabel('Value')
    ax.grid(True)

    y_max = max(np.max(data[0]), np.max(data[1]))
    y_min = min(np.min(data[0]), np.min(data[1]))
    height = y_max + 0.05 * (y_max - y_min)
    ax.plot([1, 2], [height, height], color='black')
    ax.text(1.5, height + 0.01 * (y_max - y_min),
            f"{p_to_asterisks(p_values_lower[name])} (p = {p_values_lower[name]:.4f})",
            ha='center', va='bottom', fontsize=10)

#fig.suptitle("BPRSA Feature Comparison", fontsize=18)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()
```
# fig3
- **bprsa+prsa曲线**
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import welch
#归一化函数（-1,1）
def normalize(x):
    x = (x - np.min(x)) / (np.max(x) - np.min(x))
    x = x * 2 - 1
    return x

def find_anchors(hr, T_pts, kind='dec'):
    """
    hr: 心率序列 (bpm)
    T_pts: 前后窗口大小 (样本点数)
    kind: 'dec' 找 HR↓，'acc' 找 HR↑
    """
    N = len(hr)
    idxs = np.arange(T_pts, N - T_pts)
    back = np.array([hr[i-T_pts:i].mean() for i in idxs])
    forw = np.array([hr[i:i+T_pts].mean() for i in idxs])
    if kind == 'dec':
        mask = forw < back
    else:
        mask = forw > back
    return idxs[mask]

def bprsa_localmean(anchor_sig, target_sig, fs, T, L, H, direction='dec'):
    
    #  转换 T 为样本点数
    T_pts = int(T * fs)
    anchors = find_anchors(anchor_sig, T_pts, kind=direction)

    #  截取并平均 target_sig 片段
    wL, wH = int(L * fs), int(H * fs)
    segs = []
    for a in anchors:
        if a - wL >= 0 and a + wH < len(target_sig):
            segs.append(target_sig[a-wL:a+wH])
    segs = np.array(segs)
    if segs.size == 0:
        raise RuntimeError("没有找到任何完整的锚点片段，请检查 T, L, H 设置。")

    bprsa_curve = segs.mean(axis=0)
    t_win = np.arange(-wL, wH) / fs

    # 计算归一化 PSD
    # 去直流
    sig = bprsa_curve - bprsa_curve.mean()
    f, Pxx = welch(sig, fs=fs, nperseg=min(1024, len(sig)))
    mask = (f >= 0) & (f <= 3)
    f_0_3 = f[mask]
    Pxx_0_3 = Pxx[mask]
    Pxx_norm = Pxx_0_3 / np.trapz(Pxx_0_3, f_0_3) * 100
    #Pxx_norm = Pxx / np.trapz(Pxx, f) * 100
    return t_win, bprsa_curve


def plot_bprsa_axes(ax0, ax1,
                    t1, bprsa, t2, prsa,
                    kind='dec', signal='HR', target_signal='RESP'):
    """
    ax0：BPRSA 曲线
    ax1：PRSA 曲线
    """
    # ax0：BPRSA 曲线
    ax0.plot(t1, bprsa, lw=2)
    ax0.axvline(0, color='k', lw=1, ls='--')
    ax0.set_xlabel('Time (s)')
    ax0.grid(True)
    if target_signal == 'RESP':
        ax0.set_ylabel(f'{target_signal} amp(au)')
    if signal == 'RESP':
        ax0.set_title(f'BPRSA: {signal} {"expiratory" if kind == "dec" else "inspiratory"} → {target_signal} response')
    else:
        ax0.set_title(f'BPRSA: BVP {"dec" if kind == "dec" else "acc"} → {target_signal} response')
    
    # ax1：PRSA 曲线
    ax1.plot(t2, prsa, lw=2, label='{} {} events'.format(signal, '↓' if kind == 'dec' else '↑'))
    ax1.axvline(0, color='k', lw=1, ls='--')
    ax1.set_xlabel('Time (s)')
    ax1.set_ylabel(f'{signal} deviation')
    ax1.set_title(f'PRSA: {signal} {kind}')
    ax1.legend()
    ax1.grid(True)


hr_pattern = r"060201_v01_hr_0.npy"
rr_pattern = r"060201_v01_rr_0.npy"
hr = np.load(hr_pattern)
resp = np.load(rr_pattern)
hr = normalize(hr)
resp = normalize(resp)
fs = 60
T_secs = 1.0
L_secs = H_secs = 2.0

# 分别计算 dec、acc 情形下的 BPRSA、PRSA
t_bvp_dec,   prsa_bvp1 = bprsa_localmean(hr, hr,   fs, T_secs, L_secs, H_secs, direction='dec')
t_bvp_acc,   prsa_bvp2 = bprsa_localmean(hr, hr,   fs, T_secs, L_secs, H_secs, direction='acc')
t_bprsa_dec, bprsa1    = bprsa_localmean(hr, resp, fs, T_secs, L_secs, H_secs, direction='dec')
t_bprsa_acc, bprsa2    = bprsa_localmean(hr, resp, fs, T_secs, L_secs, H_secs, direction='acc')

# 创建 figure + 4 个子图 (2行×2列)
fig, axes = plt.subplots(2, 2, figsize=(10, 8))

# 第一行绘制 dec （axes[0,0] & axes[0,1]）
plot_bprsa_axes(
    ax0=axes[0,0], ax1=axes[0,1],
    t1=t_bprsa_dec, bprsa=bprsa1, 
    t2=t_bvp_dec, prsa=prsa_bvp1,
    kind='dec', signal='BVP', target_signal='RESP'
)

# 第二行绘制 acc （axes[1,0] & axes[1,1]）
plot_bprsa_axes(
    ax0=axes[1,0], ax1=axes[1,1],
    t1=t_bprsa_acc, bprsa=bprsa2,
    t2=t_bvp_acc, prsa=prsa_bvp2,
    kind='acc', signal='BVP', target_signal='RESP'
)

plt.tight_layout()
plt.show()






```
# fig4
- **bvp和rPPG对比**
```python
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter
from scipy.signal import  welch, butter, filtfilt
def normalize(x):
    x = (x - np.min(x)) / (np.max(x) - np.min(x))
    x = x * 2 - 1
    return x

def bandpass_filter(data, lowcut=0.5, highcut=3, fs=30, order=3):
    """Apply a bandpass filter to the data."""
    
    if fs is None or fs <= 0:
        return np.zeros_like(data)
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return filtfilt(b, a, data)
rppg_rr_gamma_all=r"bvp_rr_v01_gamma_all.npy"
bvp_rr_gamma_all=r"hr_rr_v01_gamma_all.npy"
bvp_time=r"hr_rr_v01_time_gamma.npy"
rppg_time=r"bvp_rr_v01_time_gamma.npy"
rppg_wave= r"060201_v01_bvp.npy"
bvp_wave = r"060201_v01_hr_0.npy"
rppg_wave=np.load(rppg_wave)
bvp_wave = np.load(bvp_wave)
rppg_wave = normalize(rppg_wave)
bvp_wave = normalize(bvp_wave)
rppg_wave= bandpass_filter(rppg_wave, lowcut=0.5, highcut=3, fs=60, order=3)
bvp_wave = bandpass_filter(bvp_wave, lowcut=0.5, highcut=3, fs=60, order=3)

rppg_data = np.load(rppg_rr_gamma_all)
bvp_data = np.load(bvp_rr_gamma_all)
bvp_time = np.load(bvp_time)
rppg_time = np.load(rppg_time)
time=np.arange(len(rppg_wave))/60
fig, axes = plt.subplots(2, 1, figsize=(15, 8))

# BVP 和 rPPG 信号
axes[0].plot(time, bvp_wave, 'r', label='BVP_signal')
axes[0].plot(time, rppg_wave, 'b', label='rPPG_signal')
axes[0].set_title("Signal: BVP and rPPG waveform")
axes[0].legend()

# BVP_CRC 和 rPPG_CRC 
axes[1].plot(rppg_time, rppg_data * 100, 'b', label='rPPG_CRC')
axes[1].plot(bvp_time, bvp_data * 100, 'r', label='BVP_CRC')
axes[1].set_xlabel('Time(s)')
axes[1].set_ylabel('Synchronization Degree (%)')
axes[1].set_ylim(0, 35)
axes[1].set_xlim(0, 7131/60)
axes[1].set_title('Comparison of rPPG_CRC and BVP_CRC')
axes[1].legend()
axes[1].grid(True, linestyle='--', alpha=0.7)
axes[1].set_xlim([time[0], time[-1]])

plt.tight_layout()
plt.show()

```
